// backend/src/routes/reports.js
const express = require('express');
const fs = require('fs');
const path = require('path');
const jwt = require('jsonwebtoken');
const puppeteer = require('puppeteer'); // may download chromium
const PDFDocument = require('pdfkit');

const router = express.Router();
const JWT_SECRET = process.env.JWT_SECRET || 'dev_jwt_secret';
const reportsFile = path.join(__dirname, '..', '..', 'db', 'seed', 'reports.json');
const reportsDir = path.join(__dirname, '..', '..', 'storage', 'reports');

// ensure folder & metadata exist
if (!fs.existsSync(reportsDir)) fs.mkdirSync(reportsDir, { recursive: true });
if (!fs.existsSync(reportsFile)) fs.writeFileSync(reportsFile, '[]', 'utf8');

function cssStyles() {
  return `<style>
    body{font-family: Arial, sans-serif; color:#222; margin:20px}
    header{display:flex; align-items:center; gap:12px; margin-bottom:12px}
    header img{width:72px; height:72px; object-fit:cover; border-radius:8px}
    h1{font-size:18px;margin:0}
    table{width:100%; border-collapse:collapse; margin-top:10px}
    th, td{border:1px solid #ddd; padding:8px; text-align:left; font-size:12px}
    th{background:#f2f7f9}
    .small{font-size:11px;color:#555}
    .center{ text-align:center }
  </style>`;
}

function buildAttendanceHtml(center_id, date, students, attendance) {
  const presentIds = new Set(attendance.map(a => a.student_id));
  const rows = students.map((s, idx) => {
    const present = presentIds.has(s.student_id) ? 'Present' : 'Absent';
    return `<tr><td>${idx+1}</td><td>${s.student_id}</td><td>${s.name}</td><td>${s.class || ''}</td><td>${present}</td></tr>`;
  }).join('');
  return `<!doctype html><html><head><meta charset="utf-8">${cssStyles()}</head><body>
    <header>
      <img src="file:///mnt/data/A_flat-style_digital_illustration_depicts_three_st.png" alt="Pravah" />
      <div><h1>Daily Attendance Report</h1><div class="small">${center_id} • ${date}</div></div>
    </header>
    <div>Total students: ${students.length} • Present: ${attendance.length}</div>
    <table><thead><tr><th>#</th><th>Student ID</th><th>Name</th><th>Class</th><th>Status</th></tr></thead><tbody>${rows}</tbody></table>
  </body></html>`;
}

function buildDiaryHtml(center_id, date, presentCount, user, students, attendance) {
  return `<!doctype html><html><head><meta charset="utf-8">${cssStyles()}</head><body>
    <header>
      <img src="file:///mnt/data/A_flat-style_digital_illustration_depicts_three_st.png" alt="Pravah" />
      <div><h1>UPAY Daily Diary</h1><div class="small">${center_id} • ${date}</div></div>
    </header>
    <table>
      <tr><th>Center</th><td>${center_id}</td></tr>
      <tr><th>Date</th><td>${date}</td></tr>
      <tr><th>Prepared by</th><td>${user.name || user.volunteer_id || 'unknown'}</td></tr>
      <tr><th>Total Students Enrolled</th><td>${students.length}</td></tr>
      <tr><th>Students Present Today</th><td>${presentCount}</td></tr>
    </table>
    <h3>Attendance Summary</h3>
    <table><thead><tr><th>#</th><th>Student ID</th><th>Name</th><th>Present</th></tr></thead><tbody>${
      students.map((s,i)=>`<tr><td>${i+1}</td><td>${s.student_id}</td><td>${s.name}</td><td>${attendance.find(a=>a.student_id===s.student_id)?'Yes':'No'}</td></tr>`).join('')
    }</tbody></table>
    <p class="small">This is an auto-generated diary PDF from Pravah prototype.</p>
  </body></html>`;
}

// Puppeteer renderer helper
async function generatePdfWithPuppeteer(html, outPath) {
  // If Puppeteer has trouble on Windows, uncomment executablePath with your Chrome path:
  // const browser = await puppeteer.launch({ executablePath: "C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe", headless: true, args:['--no-sandbox','--disable-setuid-sandbox']});
  const browser = await puppeteer.launch({ args:['--no-sandbox','--disable-setuid-sandbox'] });
  const page = await browser.newPage();
  await page.setContent(html, { waitUntil: 'networkidle0' });
  await page.pdf({ path: outPath, format: 'A4', printBackground: true });
  await browser.close();
}

// pdfkit fallback (guarantees a valid PDF)
function generatePdfWithPdfKitPlain(diaryObj, outPath) {
  const doc = new PDFDocument({ margin: 18, size: 'A4' });
  doc.pipe(fs.createWriteStream(outPath));
  doc.fontSize(16).text('UPAY Daily Centre Report / Diary', { align: 'center' });
  doc.moveDown();
  doc.fontSize(12).text(`Center: ${diaryObj.center_id || ''}   Date: ${diaryObj.date || ''}   Prepared by: ${diaryObj.prepared_by?.name || diaryObj.prepared_by?.volunteer_id || ''}`);
  doc.moveDown();
  if (diaryObj.daily_checklist) {
    doc.fontSize(12).text('Daily Checklist:');
    Object.entries(diaryObj.daily_checklist).forEach(([k,v]) => doc.text(`${k}: ${typeof v === 'boolean' ? (v ? 'Yes' : 'No') : v}`));
    doc.moveDown();
  }
  const att = diaryObj.attendance_summary || {};
  doc.text(`Enrolled: ${att.enrolled || 0}  Present: ${att.present_count || 0}  Percentage: ${att.percentage_present || ''}`);
  doc.moveDown();
  doc.text('Volunteer Reports:');
  (diaryObj.volunteer_reports || []).forEach((vr, i) => {
    doc.text(`${i+1}. ${vr.volunteer_name || ''} | In:${vr.in_time||''} Out:${vr.out_time||''} Subject:${vr.subject_taught||''}`);
  });
  doc.end();
}

// Auth middleware
function authMiddleware(req, res, next) {
  const auth = req.headers.authorization || '';
  if (!auth.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing token' });
  try {
    req.user = jwt.verify(auth.slice(7), JWT_SECRET);
    next();
  } catch (e) { return res.status(401).json({ error: 'Invalid token' }); }
}

// List reports
router.get('/list', authMiddleware, (req, res) => {
  const center = req.query.center;
  try {
    const reports = JSON.parse(fs.readFileSync(reportsFile, 'utf8') || '[]');
    const out = center ? reports.filter(r => r.center_id === center) : reports;
    return res.json({ reports: out });
  } catch (e) {
    console.error('reports read error', e);
    return res.status(500).json({ error: 'Could not read reports' });
  }
});

// Download file
router.get('/download', authMiddleware, (req, res) => {
  const file = req.query.file;
  if (!file) return res.status(400).json({ error: 'file query param required' });
  const p = path.join(reportsDir, path.basename(file));
  if (!fs.existsSync(p)) return res.status(404).json({ error: 'report not found' });
  return res.download(p);
});

// Generate report (attendance or diary)
router.post('/generate', authMiddleware, async (req, res) => {
  try {
    const { type, center_id, date } = req.body || {};
    if (!type || !center_id) return res.status(400).json({ error: 'type and center_id required' });
    const targetDate = date || new Date().toISOString().slice(0,10);

    // load data
    const attFile = path.join(__dirname, '..', '..', 'db', 'seed', 'attendance.json');
    const studentsFile = path.join(__dirname, '..', '..', 'db', 'seed', 'students.json');
    const attendance = fs.existsSync(attFile) ? JSON.parse(fs.readFileSync(attFile,'utf8')||'[]') : [];
    const students = fs.existsSync(studentsFile) ? JSON.parse(fs.readFileSync(studentsFile,'utf8')||'[]') : [];

    const centerStudents = students.filter(s => s.center_id === center_id);
    const centerAttendance = attendance.filter(a => a.center_id === center_id && a.date === targetDate);

    // prepare HTML
    let html = '';
    if (type === 'attendance') {
      html = buildAttendanceHtml(center_id, targetDate, centerStudents, centerAttendance);
    } else if (type === 'diary') {
      const presentCount = centerAttendance.length;
      html = buildDiaryHtml(center_id, targetDate, presentCount, req.user, centerStudents, centerAttendance);
    } else {
      return res.status(400).json({ error: 'Unknown report type' });
    }

    const filename = `${center_id}_${type}_${targetDate}.pdf`.replace(/[^a-zA-Z0-9_\-\.]/g,'_');
    const outPath = path.join(reportsDir, filename);

    // Try Puppeteer; if it fails, fallback to pdfkit
    try {
      await generatePdfWithPuppeteer(html, outPath);
    } catch (puppErr) {
      console.error('Puppeteer failed, falling back to pdfkit:', puppErr && puppErr.message ? puppErr.message : puppErr);
      // build a minimal diary object for pdfkit fallback
      const diaryObj = {
        center_id,
        date: targetDate,
        prepared_by: req.user,
        daily_checklist: { note: 'Auto-generated fallback' },
        volunteer_reports: centerStudents.slice(0,3).map(s => ({ volunteer_name: s.name || '' })),
        attendance_summary: { enrolled: centerStudents.length, present_count: centerAttendance.length, percentage_present: Math.round((centerAttendance.length / Math.max(1, centerStudents.length))*100) }
      };
      generatePdfWithPdfKitPlain(diaryObj, outPath);
    }

    // save metadata
    const reports = fs.existsSync(reportsFile) ? JSON.parse(fs.readFileSync(reportsFile,'utf8')||'[]') : [];
    const rec = { file: filename, center_id, type, date: targetDate, created_at: new Date().toISOString(), created_by: req.user.volunteer_id || req.user.name || 'unknown' };
    reports.push(rec);
    fs.writeFileSync(reportsFile, JSON.stringify(reports, null, 2), 'utf8');

    return res.json({ ok: true, file: filename, path: `storage/reports/${filename}` });
  } catch (err) {
    console.error('report generate error', err);
    return res.status(500).json({ error: 'Could not generate report' });
  }
});

module.exports = router;
